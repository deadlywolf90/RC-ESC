# RC-ESC

# Electronic Stability Control for RC Cars
Project webpage: http://deadlywolf90.github.io/RC-ESC/

v1.0 2016/04/14             

IMPORTANT NOTICE: THIS PROJECT IS FAR FROM READY, SO USE IT AT YOUR OWN RISK! This project features an electronic stability control for a 1/10th scale RC car. The targetted car is a nitro-powered RC-car, but any 1/10th scale RC car is compatible with the project that has a throttle and a steering servo. The setup consists of two Arduino Nano-compatible boards on the car, an MPU-6050 breakout board (GY-521), a DPDT-relay as a safety switch, a QRD1114 infrared LED and phototransistor, as speed sensor, and an RGB-LED for feedback. For remotely changing settings, the in-car setup is equipped with an NRF24L01 radio. The remote control is a third arduino nano, connected to an LCD screen, an encoder and a similar NRF24L01 radio, providing two-way communication with the car. The rest of the components and features are optional. These include an LM338- based glow plug driver which is yet to be tested. This will rely on a thermistor or an LM335 IC and a crankshaft RPM sensor. As of 20160415 I have tested the circuit, everything works, I solved the problem with the I2C communication, and printed and assembled the pcb. (Picture on the webpage) The next step is to program the remote, design a pcb for that as well, and go test (a lot). :)

This part contains description of the finished and yet-to-be finished features: OPERATION: Currently the stability control is achieved only by throttle and steering servo control. 1/5th scale cars can include indvidual braking on each wheel, which can take stability control to a whole new level. INTERVENTION: Oversteer and understeer corrections, holding straight, ABS (anti-lock braking system), glow plug heating (startup and while running), startup help 

Some details, so one can decipher my not-too-professional code :) Inline comments are not always trustworthy :) 
DECISION: From the gyroscope/accelerometer and RPM sensor (not yet) input, and the geometry of the car, the program calculates the intended course of the car (a speed vector). It stores this vector as X and Y vectors respective to the car and a timestamp for it. In the next loop this is done again, and from the two vectors it calculates an acceleration vector. The program also calculates the centripetal acceleration for the curve that the car is negotiating. This is done for both the front and rear axles. The vectors' sum is what the car "experiences" as acceleration at its centerpoint. The difference of the sideways component of the front and rear vector is what the car "experiences" as rotation around the vertical axis at its centerpoint (called as yaw). These are the optimal values, at optimal conditions, no slip, so some tolerance is added to tune the sensitivity (this is done by remote control). The actual values are measured by the gyroscope/accelerometer. As for the understeer detection, if the acceleration vector points more towards the front of the car than calculated, or its sideways absolute value is less than calculated, means that the car is negotiating a slighter curve (a bigger radius) than intended (i.e. it is understeering). As for the oversteer detection, if there is more yaw, (i.e the car rotates around its center more) than expected, it means, that the rear end of the car has slipped out from the curve (fishtailed). Also in rare cases similar slip can occur at the front, (but that means towards the inside of the curve, such cases can be sudden increase in grip, or getting side-bumped by another car) but the response is essentially the same for both cases. 
OVERSTEER-CORRECTION: if the program finds that the car rotates around its vertical axis more than it is supposed to be, that means the car is fishtailing. It stores the last steering input before the car started to skid, and adjusts the steering so that the front wheels try to face the original course of the car (in one word: countersteering) and reducing throttle to regain tyre grip. This behaviour can be fine-tuned at sensitivity, so it can let some sliding, and at intervention, i.e. how agressive the countersteering is. 
UNDERSTEER-CORRECTION: as there are no seperate brakes for every wheel, the only intervention that is possible is reducing throttle, so the tyres get more grip. However, one condition has to be added, braking is not allowed, as it will reduce grip, and worsen the condition. No braking vs. ABS braking in this situation is yet to be tested. This feature is also fine tuneable, and needs testing for every car so as not to reduce power too much. 
HOLDING-STRAIGHT: if the controller's steering wheel is centered, we want the car to go straight, so if there is sideways acceleration in this situation the car is negotiating a curve (to my experience this happens with entry-level RC cars). To counteract this, the program uses very slight (of course) fine-tuneable countersteering. 
STARTUP AND GLOWPLUG HEATING: This is the feature that has to be developed and tested the most. At startup (as there is no choke valve here) a small throttle is added, until the point that the wheels are not turning, and the thermistor measures engine temp. As optimal temp is reached extra throttle is reduced, and glow is switched off. If during run engine cools down, if absolutely necessary the glow plug is switched on again, hopefully not draining too much battery. 
SAFETY AND OTHER: Battery level is monitored by the other arduino, and the other arduino also acts as a failsafe. If the first arduino (with this program on) freezes for some reason, the second arduino pulls a DPDT relay low, bypassing remote control directly to the servos. It also resets the other arduino, hoping that the problem can be resolved. 

Any feedback is appreciated, I am planning on posting circuit and other info later on, I am not yet sure where. In the meantime enjoy this code. Be gentle, as this is my first such project, and I am new to github. Questions and feedback email: gmarci90+ESC@gmail.com 

VERY SPECIAL THANKS TO DuaneB for the Basics (interfacing with the receiver and servos, and readingwriting settings to and from EEPROM) were adapted from RCArduinoYawControlby DuaneB at rcarduino.blogspot.com. RCArduinoYawControl by DuaneB is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. VERY SPECIAL THANKS TO Jeff Rowberg for the I2Cdevlib and the MPU6050 libraries ALSO THANKS TO madsci1016 for the EasyTransfer library so I don't have to fiddle with bits to send data over I2C

This project is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. https:creativecommons.orglicensesby-nc-sa4.0
